<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>RxJava 响应式编程 | 布衣世佳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '06bf312fea7545812ff68aee08debd1d';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RxJava 响应式编程</h1><a id="logo" href="/.">布衣世佳</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RxJava 响应式编程</h1><div class="post-meta">Sep 7, 2018<span> | </span><span class="category"><a href="/categories/RxJava/">RxJava</a></span></div><a class="disqus-comment-count" href="/2018/09/07/rxjava-intro/#vcomment"><span class="valine-comment-count" data-xid="/2018/09/07/rxjava-intro/"></span><span> 条评论</span></a><div class="post-content"><h2 id="RxJava-是什么"><a href="#RxJava-是什么" class="headerlink" title="RxJava 是什么"></a>RxJava 是什么</h2><blockquote>
<p>a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</p>
<p>一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库</p>
</blockquote>
<p>简单来说，RxJava是基于事件流的响应式编程，下面结合例子说明一下响应式编程是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init variables</span></span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init inputs</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set output value</span></span><br><span class="line">k = i + j;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update a dependent value</span></span><br><span class="line">j = <span class="number">4</span>;</span><br><span class="line">k = ?  <span class="comment">// What should k be?</span></span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，<code>k = i + j</code> ，但是当 <code>j</code> 的值发生改变后，<code>k</code> 的值并不随 <code>j</code> 的改变而改变。而响应式编程就是一种能让 <code>k</code> 随着 <code>j</code> 的改变而改变的编程模式。传统的异步编程一般用回调函数的方式来完成更新操作，在遇到嵌套异步任务（例如嵌套的网络请求），往往会导致逻辑复杂、代码晦涩难懂、容易出现各种各样bug。多个层级的嵌套回调，很容易导致<a href="http://callbackhell.com/" target="_blank" rel="noopener">回调地狱</a>，响应式编程就能很好的解决这种问题。</p>
<h2 id="RxJava-的优点"><a href="#RxJava-的优点" class="headerlink" title="RxJava 的优点"></a>RxJava 的优点</h2><ul>
<li><strong>简单</strong>：能够轻松的应对异步任务、嵌套请求、嵌套回调的情况</li>
<li><strong>线程调度清晰</strong>：能轻松的指定任务执行的线程，两行代码就能实现后台执行耗时任务、前台显示的线程调度</li>
<li><strong>统一的错误处理</strong>：在嵌套的回调中往往需要在多处处理错误信息，RxJava只需在一个地方处理就可以</li>
<li><strong>减少不必要的中间状态变量</strong>：多个异步任务同时执行时，会需要一下中间状态变量（例如各种标志位）来控制执行的顺序，从而会导致各种奇怪的bug，而基于数据流的Rxjava则不需要这些变量，代码更加简洁，质量也会更高。</li>
</ul>
<h2 id="开始使用-RxJava"><a href="#开始使用-RxJava" class="headerlink" title="开始使用 RxJava"></a>开始使用 RxJava</h2><h3 id="RxJava-配置"><a href="#RxJava-配置" class="headerlink" title="RxJava 配置"></a>RxJava 配置</h3><p>首先需要添加配置导入RxJava 库 <code>app/build.gradle</code>:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">implementation</span> <span class="string">'io.reactivex:rxandroid:1.2.0'</span></span><br><span class="line">  <span class="keyword">implementation</span> <span class="string">'io.reactivex:rxjava:1.1.4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用RxJava的时强烈推荐使用Lambda表达式，可以减少很多代码量。为简单起见，本文不使用Lambda表达式，可自行百度学习</p>
</blockquote>
<h3 id="被观察者与观察者"><a href="#被观察者与观察者" class="headerlink" title="被观察者与观察者"></a>被观察者与观察者</h3><p>RxJava是建立在被观察者和观察者两者的关系之上，观察者订阅被观察者后，被观察者一旦发生变化就会通知观察者。</p>
<p><code>observable</code> 表示被观察者，可以发射一系列事件。<code>observer</code> 是观察者，可以消耗 <code>observable</code> 发射出来的事件。当 <code>observer</code> 订阅  <code>observable</code> 后，<code>observable</code> 才开始发射事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onNext value："</span> + integer );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行以上代码，会打印如下信息：</span></span><br><span class="line"><span class="comment">// onNext value：1</span></span><br><span class="line"><span class="comment">// onNext value：2</span></span><br><span class="line"><span class="comment">// onNext value：3</span></span><br><span class="line"><span class="comment">// onCompleted</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，被观察者 <code>Observables</code> 通过操作符 <code>just</code> 依次发射数据 <code>1,2,3</code> 。观察者 <code>Observer</code> 通过操作符 <code>subscribe</code> 订阅后，<code>observables</code> 开始发射数据， <code>Observer</code> 的 <code>onNext()</code> 方法就能接收并消耗掉数据，<code>observables</code> 发射结束后，就会收到             <code>onCompleted</code> 事件，整个过程结束。若这个过程中发生错误，就会收到 <code>onError</code> 事件，可在此处做同一的错误处理。</p>
<p><code>Observables</code> 常用的发射操作符还有：</p>
<ul>
<li><strong>from</strong>：将其它种类的对象和数据类型转换为Observable</li>
<li><strong>interval</strong>：创建一个按固定时间间隔发射整数序列的Observable</li>
<li><strong>repeat</strong>：创建一个发射特定数据重复多次的Observable</li>
<li><strong>timer</strong>：创建一个Observable，它在一个给定的延迟后发射一个特殊的值。</li>
</ul>
<p><code>Observer</code> 常用它的抽象类 <code>Subscriber</code> 代替，事实上 <code>Observer</code> 在订阅的时候也会先转化为 <code>Subscriber</code> ，下文将统一采用 <code>Subscriber</code> 。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>默认情况下，RxJava 是在哪订阅就在哪发射事件和消耗事件，即：都是在调用 <code>subsribe()</code> 线程内执行。若需要切换线程，就要使用线程调度 <code>Scheduler</code> 。</p>
<p>线程调度使用到以下两个操作符：</p>
<ul>
<li>subscribeOn：指定<code>subscribe()</code>所发生的线程，即事件产生的线程，仅一次有效。</li>
<li>observeOn：指定<code>Subscriber</code>所运行在的线程，即事件消费的线程，可多次调用，达到多次切换线程的效果。</li>
</ul>
<p>线程调度的类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Schedulers.computation()</td>
<td style="text-align:left">计算型线程</td>
</tr>
<tr>
<td style="text-align:left">Schedulers.immediate()</td>
<td style="text-align:left">当前线程</td>
</tr>
<tr>
<td style="text-align:left">Schedulers.io()</td>
<td style="text-align:left">IO线程，网络、数据存取等</td>
</tr>
<tr>
<td style="text-align:left">Schedulers.newThread()</td>
<td style="text-align:left">新的线程</td>
</tr>
<tr>
<td style="text-align:left">AndroidSchedulers.mainThread()</td>
<td style="text-align:left">Android主线程</td>
</tr>
</tbody>
</table>
<p>其中Android主线程的参数 <code>AndroidScheduler.mainThread()</code><br>需要添加以下依赖：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'io.reactivex:rxandroid:1.2.1'</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中加上 <code>subscribeOn(Schedulers.io()</code> 、 <code>observeOn(AndroidSchedulers.mainThread())</code> 两行代码，即可完成在后台执行耗时操作，在主线程更新界面的线程切换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io()) <span class="comment">// 在IO线程上调用，执行耗时操作</span></span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 在主线程回调</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onNext value："</span> + integer );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行以上代码，会打印如下信息：</span></span><br><span class="line"><span class="comment">// onNext value：1</span></span><br><span class="line"><span class="comment">// onNext value：2</span></span><br><span class="line"><span class="comment">// onNext value：3</span></span><br><span class="line"><span class="comment">// onCompleted</span></span><br></pre></td></tr></table></figure>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>RxJava 是基于事件流的响应式编程，事件流的变化是其核心功能之一。<br>变换，就是对输入的事件进行加工处理后输出另一个事件。例如上面例子输入的事件是 <code>1</code> ，<code>2</code> ，<code>3</code> ，需要输出其对应的英文单词 <code>one</code> ，<code>two</code> ，<code>three</code> ，将 <code>1</code> 转为 <code>one</code> 的过程就叫做变换。</p>
<p>RxJava 常用的变换操作符有 <code>map</code> 和 <code>flatMap</code> 。</p>
<ul>
<li><strong>map</strong> ：对 <code>Observable</code> 发射的每一项数据应用一个函数，执行变换操作，然后返回一个发射这些结果的<code>Observable</code></li>
<li><strong>flatMap</strong>：将一个发射数据的 <code>Observable</code> 变换为多个（也可以是一个，只返回一个效果等同于map） <code>Observable</code> ，然后将它们发射的数据合并后放进一个单独的 <code>Observable</code> ，只需订阅最后一个<code>Observable</code> 即可。</li>
</ul>
<p>看不懂？没关系，接着往下看。</p>
<p>map 示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123; <span class="comment">// 将数字变换为英文字符串</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                String en = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">switch</span> (integer) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        en = <span class="string">"one"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        en = <span class="string">"two"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        en = <span class="string">"three"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> en;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onNext value："</span> + word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行以上代码，会打印如下信息：</span></span><br><span class="line"><span class="comment">// onNext value：one</span></span><br><span class="line"><span class="comment">// onNext value：two</span></span><br><span class="line"><span class="comment">// onNext value：three</span></span><br><span class="line"><span class="comment">// onCompleted</span></span><br></pre></td></tr></table></figure></p>
<p>flatMap 示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello world"</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入的一个事件 “Hello world”,输入两个事件：“hello”和“world”</span></span><br><span class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.from(s.split(<span class="string">" "</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"onNext value："</span> + word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 执行以上代码，会打印如下信息：</span></span><br><span class="line"><span class="comment">// onNext value：Hello</span></span><br><span class="line"><span class="comment">// onNext value：world</span></span><br><span class="line"><span class="comment">// onCompleted</span></span><br></pre></td></tr></table></figure></p>
<p>通过两个示例可以看出，<code>map</code> 操作符返回的是具体是事件（例子中返回的是String），<code>flatMap</code> 操作符返回的是<code>Observable</code>（例子中是返回Observable）。</p>
<h3 id="防止内存泄露"><a href="#防止内存泄露" class="headerlink" title="防止内存泄露"></a>防止内存泄露</h3><p>RxJava在订阅 <code>Observable</code> 时会保存一个引用，如果没有在合适的时机取消订阅，则可能会导致内存泄露。例如在Activity里执行网络请求，那么应该在 <code>onPause()</code> 中取消订阅。</p>
<p>取消订阅的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅时返回 Subscription，可用于取消订阅</span></span><br><span class="line">Subscription subscription = Observable.just(<span class="number">1</span>).subscribe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅前，先判断是否还是订阅状态</span></span><br><span class="line"><span class="keyword">if</span> (subscription != <span class="keyword">null</span> &amp;&amp; !subscription.isUnsubscribed()) &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三方库 <a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">RxLifecycle</a> 提供与Activity、Fragment生命周期相关的方法，自动取消订阅，能够有效的防止RxJava未取消订阅而导致的内存泄露。</p>
<h2 id="有用的库"><a href="#有用的库" class="headerlink" title="有用的库"></a>有用的库</h2><p>结合这些库使用，RxJava能变的更加强大。</p>
<ul>
<li><a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a><strong>：</strong>http请求库</li>
<li><a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">RxLifecycle</a>：根据Android生命周期管理RxJava</li>
<li><a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">RxBinding</a>：对Android View事件的扩展，它使得你可以对View事件使用RxJava的各种操作</li>
<li><a href="https://github.com/tbruyelle/RxPermissions" target="_blank" rel="noopener">RxPermissions</a>：RxJava的方式动态申请权限</li>
<li><a href="https://github.com/ReactiveX/RxAndroid/wiki#extensions" target="_blank" rel="noopener">更多的库…</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></li>
<li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">ReactiveX/RxJava文档中文版</a></li>
<li><a href="https://guides.codepath.com/android/RxJava" target="_blank" rel="noopener">RxJava Intro</a></li>
</ul>
</div><div class="tags"><a href="/tags/RxJava/">RxJava</a></div><div class="post-nav"><a class="next" href="/2018/09/01/mqtt-introduction/">MQTT--普遍用于物联网、消息推送的轻量级消息传输协议</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'huuoEBnT8rjJWI0JpHIteXwh-gzGzoHsz',
  appKey:'IgFPmbD0TqtDawiS22bOjtTk',
  placeholder:'Just so so',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava/">RxJava</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mqtt/">mqtt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客/">博客</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/mqtt/" style="font-size: 15px;">mqtt</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/rxjava-intro/">RxJava 响应式编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/mqtt-introduction/">MQTT--普遍用于物联网、消息推送的轻量级消息传输协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/markdown-introduction/">Markdown使用介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/build-blog/">博客搭建过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/flutter-http/">Flutter之HTTP请求</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/flutter-introduction/">Flutter之扫盲篇</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://hexo.io/zh-cn/docs/" title="hexo文档" target="_blank">hexo文档</a><ul></ul><a href="http://visugar.com/2017/05/04/20170504SetUpHexoBlog/" title="hexo安装教程" target="_blank">hexo安装教程</a><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="主题配置教程" target="_blank">主题配置教程</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">布衣世佳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>