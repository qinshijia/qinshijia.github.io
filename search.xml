<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RxJava 响应式编程]]></title>
    <url>%2F2018%2F09%2F07%2Frxjava-intro%2F</url>
    <content type="text"><![CDATA[RxJava 是什么 a library for composing asynchronous and event-based programs using observable sequences for the Java VM. 一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库 简单来说，RxJava是基于事件流的响应式编程，下面结合例子说明一下响应式编程是什么。 12345678910111213// init variablesint i, j, k;// Init inputsi = 1;j = 2;// Set output valuek = i + j;// Update a dependent valuej = 4;k = ? // What should k be? 在上面这段代码中，k = i + j ，但是当 j 的值发生改变后，k 的值并不随 j 的改变而改变。而响应式编程就是一种能让 k 随着 j 的改变而改变的编程模式。传统的异步编程一般用回调函数的方式来完成更新操作，在遇到嵌套异步任务（例如嵌套的网络请求），往往会导致逻辑复杂、代码晦涩难懂、容易出现各种各样bug。多个层级的嵌套回调，很容易导致回调地狱，响应式编程就能很好的解决这种问题。 RxJava 的优点 简单：能够轻松的应对异步任务、嵌套请求、嵌套回调的情况 线程调度清晰：能轻松的指定任务执行的线程，两行代码就能实现后台执行耗时任务、前台显示的线程调度 统一的错误处理：在嵌套的回调中往往需要在多处处理错误信息，RxJava只需在一个地方处理就可以 减少不必要的中间状态变量：多个异步任务同时执行时，会需要一下中间状态变量（例如各种标志位）来控制执行的顺序，从而会导致各种奇怪的bug，而基于数据流的Rxjava则不需要这些变量，代码更加简洁，质量也会更高。 开始使用 RxJavaRxJava 配置首先需要添加配置导入RxJava 库 app/build.gradle: 1234dependencies &#123; implementation 'io.reactivex:rxandroid:1.2.0' implementation 'io.reactivex:rxjava:1.1.4'&#125; 使用RxJava的时强烈推荐使用Lambda表达式，可以减少很多代码量。为简单起见，本文不使用Lambda表达式，可自行百度学习 被观察者与观察者RxJava是建立在被观察者和观察者两者的关系之上，观察者订阅被观察者后，被观察者一旦发生变化就会通知观察者。 observable 表示被观察者，可以发射一系列事件。observer 是观察者，可以消耗 observable 发射出来的事件。当 observer 订阅 observable 后，observable 才开始发射事件。 1234567891011121314151617181920212223Observable.just(1, 2, 3) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted"); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext value：" + integer ); &#125; &#125;);// 执行以上代码，会打印如下信息：// onNext value：1// onNext value：2// onNext value：3// onCompleted 以上代码中，被观察者 Observables 通过操作符 just 依次发射数据 1,2,3 。观察者 Observer 通过操作符 subscribe 订阅后，observables 开始发射数据， Observer 的 onNext() 方法就能接收并消耗掉数据，observables 发射结束后，就会收到 onCompleted 事件，整个过程结束。若这个过程中发生错误，就会收到 onError 事件，可在此处做同一的错误处理。 Observables 常用的发射操作符还有： from：将其它种类的对象和数据类型转换为Observable interval：创建一个按固定时间间隔发射整数序列的Observable repeat：创建一个发射特定数据重复多次的Observable timer：创建一个Observable，它在一个给定的延迟后发射一个特殊的值。 Observer 常用它的抽象类 Subscriber 代替，事实上 Observer 在订阅的时候也会先转化为 Subscriber ，下文将统一采用 Subscriber 。 线程调度默认情况下，RxJava 是在哪订阅就在哪发射事件和消耗事件，即：都是在调用 subsribe() 线程内执行。若需要切换线程，就要使用线程调度 Scheduler 。 线程调度使用到以下两个操作符： subscribeOn：指定subscribe()所发生的线程，即事件产生的线程，仅一次有效。 observeOn：指定Subscriber所运行在的线程，即事件消费的线程，可多次调用，达到多次切换线程的效果。 线程调度的类型： 类型 描述 Schedulers.computation() 计算型线程 Schedulers.immediate() 当前线程 Schedulers.io() IO线程，网络、数据存取等 Schedulers.newThread() 新的线程 AndroidSchedulers.mainThread() Android主线程 其中Android主线程的参数 AndroidScheduler.mainThread()需要添加以下依赖：1compile 'io.reactivex:rxandroid:1.2.1' 在上面的例子中加上 subscribeOn(Schedulers.io() 、 observeOn(AndroidSchedulers.mainThread()) 两行代码，即可完成在后台执行耗时操作，在主线程更新界面的线程切换。 12345678910111213141516171819202122232425Observable.just(1, 2, 3) .subscribeOn(Schedulers.io()) // 在IO线程上调用，执行耗时操作 .observeOn(AndroidSchedulers.mainThread()) // 在主线程回调 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted"); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext value：" + integer ); &#125; &#125;);// 执行以上代码，会打印如下信息：// onNext value：1// onNext value：2// onNext value：3// onCompleted 变换RxJava 是基于事件流的响应式编程，事件流的变化是其核心功能之一。变换，就是对输入的事件进行加工处理后输出另一个事件。例如上面例子输入的事件是 1 ，2 ，3 ，需要输出其对应的英文单词 one ，two ，three ，将 1 转为 one 的过程就叫做变换。 RxJava 常用的变换操作符有 map 和 flatMap 。 map ：对 Observable 发射的每一项数据应用一个函数，执行变换操作，然后返回一个发射这些结果的Observable flatMap：将一个发射数据的 Observable 变换为多个（也可以是一个，只返回一个效果等同于map） Observable ，然后将它们发射的数据合并后放进一个单独的 Observable ，只需订阅最后一个Observable 即可。 看不懂？没关系，接着往下看。 map 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.just(1, 2, 3) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(new Func1&lt;Integer, String&gt;() &#123; // 将数字变换为英文字符串 @Override public String call(Integer integer) &#123; String en = ""; switch (integer) &#123; case 1: en = "one"; break; case 2: en = "two"; break; case 3: en = "three"; break; &#125; return en; &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted"); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String word) &#123; System.out.println("onNext value：" + word); &#125; &#125;);// 执行以上代码，会打印如下信息：// onNext value：one// onNext value：two// onNext value：three// onCompleted flatMap 示例：12345678910111213141516171819202122232425262728293031Observable.just("Hello world") .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 输入的一个事件 “Hello world”,输入两个事件：“hello”和“world” .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(String s) &#123; return Observable.from(s.split(" ")); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted"); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String word) &#123; System.out.println("onNext value：" + word); &#125; &#125;);// 执行以上代码，会打印如下信息：// onNext value：Hello// onNext value：world// onCompleted 通过两个示例可以看出，map 操作符返回的是具体是事件（例子中返回的是String），flatMap 操作符返回的是Observable（例子中是返回Observable）。 防止内存泄露RxJava在订阅 Observable 时会保存一个引用，如果没有在合适的时机取消订阅，则可能会导致内存泄露。例如在Activity里执行网络请求，那么应该在 onPause() 中取消订阅。 取消订阅的方法如下：1234567// 订阅时返回 Subscription，可用于取消订阅Subscription subscription = Observable.just(1).subscribe();// 取消订阅前，先判断是否还是订阅状态if (subscription != null &amp;&amp; !subscription.isUnsubscribed()) &#123; subscription.unsubscribe();&#125; 第三方库 RxLifecycle 提供与Activity、Fragment生命周期相关的方法，自动取消订阅，能够有效的防止RxJava未取消订阅而导致的内存泄露。 有用的库结合这些库使用，RxJava能变的更加强大。 Retrofit：http请求库 RxLifecycle：根据Android生命周期管理RxJava RxBinding：对Android View事件的扩展，它使得你可以对View事件使用RxJava的各种操作 RxPermissions：RxJava的方式动态申请权限 更多的库… 参考资料 给 Android 开发者的 RxJava 详解 ReactiveX/RxJava文档中文版 RxJava Intro]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT--普遍用于物联网、消息推送的轻量级消息传输协议]]></title>
    <url>%2F2018%2F09%2F01%2Fmqtt-introduction%2F</url>
    <content type="text"><![CDATA[MQTT是什么MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。针对高延迟或不可靠的网络进行了优化，同时还确保了网络传输的可靠性。适合用于带宽小、内存小、处理能力有限、网络不可靠的环境。具有这些特点的MQTT很适合用于嵌入式设备，已普遍用于智能设备、医疗、智能汽车等领域。在Android、IOS等移动开发中，普遍作为消息推送的解决方案。 MQTT有谁在用 阿里巴巴 ：阿里云提供的IOT解决方案：https://www.aliyun.com/aliware/scenarios/case1 Facebook Messenger ：Facebook出品的聊天工具 EMQ ：百万级分布式开源物联网MQTT消息服务器：http://www.emqtt.com/ 云智易 ：云智易的设备是基于MQTT协议传输数据从而实现设备数据的上报与控制 网易云信 ：其核心也是MQTT来实现消息推送的 还有更多的使用例子：https://github.com/mqtt/mqtt.github.io/wiki/Example-Uses MQTT是怎么工作的MQTT采用的是发布/订阅的方式通信，客户端（Client）发布消息，经由代理（Broker）转发给订阅者（也是客户端）。 村民：狼来了，就喊救命，我来赶跑它。小男孩：知道了狼来了。小男孩：狼来了！狼来了！救命啊！村民过来把狼赶跑了。 订阅者（村民）通过主题（狼来了）向代理（小男孩）订阅消息，当发布者（狼）发布该主题的消息（狼来了）时，代理就将消息转发给此消息主题的订阅者（小男孩通知村民），订阅者就可以做出响应（把狼赶跑了）。订阅者和发布者都属于客户端，可以是一个设备或者一个应用程序。每个客户端都拥有唯一的ClientID。 MQTT底层采用的是TCP/IP实现，提供三种服务质量（QoS）： 至多一次 ：消息发布成功与否完全依赖底层网络，消息可能会丢失。适用于要求不高的数据。 至少一次 ：消息会确保到达，但是可能会重复。 只有一次 ：消息确保到达一次，可用于数据要求比较高的环境，如计费系统。 MQTT的一些术语客户端 Client使用MQTT的程序或设备。客户端总是通过网络连接到服务端。它可以 发布应用消息给其它相关的客户端。 订阅以请求接受相关的应用消息。 取消订阅以移除接受应用消息的请求。 从服务端断开连接。 服务端 Server一个程序或设备，作为发送消息的客户端和请求订阅的客户端之间的中介。服务端 接受来自客户端的网络连接。 接受客户端发布的应用消息。 处理客户端的订阅和取消订阅请求。 转发应用消息给符合条件的已订阅客户端。 订阅 Subscription订阅包含一个主题过滤器（Topic Filter）和一个最大的服务质量（QoS）等级。订阅与单个会话（Session）关联。会话可以包含多于一个的订阅。会话的每个订阅都有一个不同的主题过滤器。 主题名 Topic Name附加在应用消息上的一个标签，服务端已知且与订阅匹配。服务端发送应用消息的一个副本给每一个匹配的客户端订阅。 主题过滤器 Topic Filter订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。 会话 Session客户端和服务端之间的状态交互。一些会话持续时长与网络连接一样，另一些可以在客户端和服务端的多个连续网络连接间扩展。 控制报文 MQTT Control Packet通过网络连接发送的信息数据包。MQTT规范定义了十四种不同类型的控制报文，其中一个（PUBLISH报文）用于传输应用消息。 MQTT的怎么用？首先，你要有个服务器，然后在服务器上部署MQTT环境，具体方法这里就不展开讲了。只想试试就不用自己部署服务器了，有很多服务器提供免费测试使用，public_brokers。示例Android工程在这里：https://github.com/bytehala/android-mqtt-quickstartMQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有： Connect。等待与服务器建立连接。 Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。 Subscribe。等待完成订阅。 UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。 Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。 参考资料What is mqtt？ MQTT wiki MQTT协议中文版]]></content>
      <categories>
        <category>mqtt</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用介绍]]></title>
    <url>%2F2018%2F08%2F13%2Fmarkdown-introduction%2F</url>
    <content type="text"><![CDATA[Markdown简介Markdown是一种轻量级的标记语言，目标是实现易读易写。 简单的语法规则，漂亮的显示效果，容易读写随意改，是Markdown的特点。使用Markdown写作，能让您专注于内容，不需要浪费大量时间去排版。很多博客、在线笔记等工具都支持Markdown格式的文档，例如GitHub、Stack Overflow、简书、为知笔记。 下面会介绍常用的Markdown语法。 Markdown语法标题Markdown中标题分为六级，在行首以 # 开头并空一格再写标题文字。# 的个数标题的级数，一级标题字体最大，六级标题字体最小。123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 段落段落没有标记，段落的前后应该有一个以上空行。段落不推荐使用缩进。 链接链接标记是一个中括号和一个小括号连在一块，中括号内是要链接的文字，小括号是链接地址，例如这样。链接可以是绝对地址，也可以是相对地址。1[百度](https://www.baidu.com/) 图片插入图片需要先保存好图片，然后再通过引入图片的方式显示。 图片的标记是一个感叹号、中括号和小括号连在一起，中括号里是图片加载不出来时显示的文字，小括号里是图片的链接地址。 下面这张图片的写法是：1![Markdown图标](https://d33wubrfki0l68.cloudfront.net/f1f475a6fda1c2c4be4cac04033db5c3293032b4/513a4/assets/images/markdown-mark-white.svg) 段内代码段内代码标记是由两个 ` 符号（键盘上制表符上面，1旁边的按键）组成，两个`中间是要显示的代码，例如这样 Hello world!。1`Hello world!` 代码块代码块是在开头和结尾都以三个连续的 ` 符号组成，中间为显示的代码。怎么没有行号？那是Markdown解析后前端显示的问题，不是语法的问题。12String text = "Hello world!";System.out.print(text); 引用在段落的开头使用 &gt; 符号即可，显示的效果如下： 这是一段引用 1&gt; 这是一段引用 无序序列无序序列在行开头使用 * 或者 - 或者 + 即可。显示效果如下 无序序列 无序序列 无序序列 123* 无序序列- 无序序列+ 无序序列 有序序列有序列表则使用数字接着一个英文句点，数字的大小顺序对显示的结果没有影响，显示结果会按照行的顺序重新编号。 有序序列1 有序序列2 有序序列3 1231. 有序序列11. 有序序列21. 有序序列3 表格表格是用符号 | 标记，在 | 之间的就是表格的内容。第一行是表头，第二行是控制表格显示方式，第三行以后是表格内容。 靠左显示 居中显示 靠右显示 第二行使用符号 :- 第二行使用符号 :-: 第二行使用符号 -: 123|靠左显示|居中显示|靠右显示||:-|:-:|-:||第二行使用符号 :-|第二行使用符号 :-:|第二行使用符号 -:| 强调强调是在段内的 * 之间插入要强调的文字，一个*是斜体，连续两个 **是加粗，例如 我想倾斜一下， 我想加粗一下。 12*我想倾斜一下***我想加粗一下** Markdown工具推荐Markdown 语法已经足够简单了，使用常用的文本编辑器就能完成写作。随着 Markdown 越来越流行，配套工具也丰富了起来，语法高亮、实时预览、图片粘贴等功能也很吸引人。 这里推荐一款文本编辑器 Atom，它着丰富的插件库，在 Atom 的 File -&gt; settings -&gt; install中搜索相应插件然后安装即可，使用方法在搜索结果界面点进去都有介绍。 Markdown 相关的插件有以下这些： markdown-writer：语法高亮 markdown-scroll-sync：编写的时候按了 Ctrl + Shift + M，之后能同步滚动预览 markdown-image-assistant：截图之后直接按 Ctrl + V 粘贴 其他工具可以看一下Markdown 在线编辑阅读器及应用收集。 参考文档Markdown 教程]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建过程]]></title>
    <url>%2F2018%2F08%2F09%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[记录一下博客网站的搭建过程，使用 Github 提供的 GitHub Pages + Hexo 实现。GitHub Pages 是 GitHub 提供的静态网页服务，文件存储在 GitHub 仓库中，可以结合 Jekyll、Hexo 等博客框架，快速的部署博客网站，同时还可以绑定个人域名，成为你的专属网站。Hexo 是一个快速、简洁且高效的博客框架，文档清晰，插件、主题丰富，使用 Makedown 解析文章，生成静态网页。使用 GitHub Pages + Hexo 即可快速部署漂亮的博客，让您专注博客内容。 博客的搭建过程参考了官方教程和一些网上的教程，“不重复造轮子”，我不再详细描写具体的配置过程，而是直接贴出教程的链接，方便查阅。 搭建过程主要以下几个步骤： 建立 GitHub Pages 仓库 安装、部署 Hexo 配置主题 安装插件 编写博客 在贴出的教程链接中，会有交叉的地方，请注意辨别。 建立GitHub Pages仓库建立 GitHub Pages 仓库，首先要有 GitHub 账号，然后在 GitHub 上建立一个命名为 [你GitHub用户名].github.io的仓库。需要注意的是，仓库的命名必须为你GitHub的用户名，否则将不生效，就不能通过 https://[你GitHub用户名].github.io 来访问。 官方教程点击这里。 建好仓库之后，在仓库里面上传一个 index.html 文件，然后通过 https://[你GitHub用户名].github.io 来访问，可以看到index.html的内容，就说明已经建立好。上传后直接访问可能会出现404，等几分钟就好了。确认仓库已经建好，用来测试的 index.html 文件就可以删除了。 在搭建博客、编写博客的过程中，基本都用不上 Git 命令，但博客是基于 GitHub 的仓库实现的，还是推荐了解一下 Git 命令，方便解决各种问题。这里推荐一个简单清晰的git教程：廖雪峰Git教程。 安装、部署HexoHexo 是基于 node.js 实现的，所以需要在自己电脑上安装 node.js，Hexo 没有可视化界面，需要使用命令行来完成各种功能，为了便于使用命令行，所以还要安装 Fit Bash。有了 node.js 和 Git Bash 之后，就可以愉快的在上面敲命令行安装、部署 Hexo 了。 安装的方法官方教程里都有，点击这里，官方教程比较全面，也会比较繁琐。 还有一个比较简单的教程，点击这里，里面还会教你怎么新建 GitHub 仓库，可以直接跳过，使用上面建好的就可以了。 到这里，部署 Hexo，并发布到 GitHub 仓库之后，博客就已经搭建完了。 不过，你可能还不太满意，界面不漂亮、没有站内搜索、没有RSS… 界面不漂亮？换个主题吧。 配置主题好看的主题都在这里，点击进去预览，然后根据主题的配置方法配置即可。 我使用的主题是 maupassant，大道至简，里面有详细的配置方法，按需配置即可。 本地配置好之后，使用 Hexo 发布命令 hexo deploy，就可以在 https://[你GitHub用户名].github.io 上看到效果。 安装插件想要站内搜索，推荐这个插件：hexo-generator-search 想要RSS，推荐这个插件：hexo-generator-feed 还想安装其他的？都在这里。 漂亮的博客网站已经建好了，开始书写内容吧。 编写博客Hexo 是将 Markdown 文件解析为静态网页，所以博客也需要使用 Markdown 格式书写。Markdown 的目标是实现「易读易写」，所以使用起来很简单，这里是官方教程。 Markdown 的编辑器有很多，我使用的是 Atom，加上下面这些插件，即可方便的书写博客。 markdown-writer：高亮显 示Markdown markdown-scroll-sync：编写的时候按了 Ctrl + Shift + M，之后能同步滚动预览 markdown-image-assistant：截图之后直接按 Ctrl + V 粘贴 在 Atom 的 File -&gt; settings -&gt; install中搜索相应插件然后安装即可，使用方法在搜索结果界面点进去都有介绍。 好了，专注内容吧。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter之HTTP请求]]></title>
    <url>%2F2018%2F08%2F06%2Fflutter-http%2F</url>
    <content type="text"><![CDATA[APP开发或多或少都要用到http网络请求，在Flutter中http请求的使用方式非常简单，只需在引入http库，设置url等必要参数后，调用http.get()或者http.post()方法即可。 Get方式请求首先需要在 pubspec.yaml 中添加依赖： 123dependencies: ... http: '&gt;=0.11.3+16' 然后调用http.get()方法即可：12345678import 'package:http/http.dart' as http;[...] loadData() async &#123; String dataURL = "https://api.bmob.cn/1/classes/book/"; http.Response response = await http.get(dataURL); print("response body : $&#123;response.body&#125;"); &#125;&#125; 设置http请求头 header：123456789loadData() async &#123; String dataUrl = "https://api.bmob.cn/1/classes/book/"; Map&lt;String, String&gt; map = new Map(); map["Content-Type"] = "application/json"; map["X-Bmob-Application-Id"] = "ce30565639d0fb10cd925b5b024c3408"; map["X-Bmob-REST-API-Key"] = "4057ff07b1bec5590fb4ff0a16141938"; http.Response response = await http.get(dataUrl, headers: map); print("$&#123;response.body&#125;");&#125; 请求成功后刷新界面：1234567891011121314151617loadData() async &#123; String dataUrl = "https://api.bmob.cn/1/classes/book/"; Map&lt;String, String&gt; map = new Map(); map["Content-Type"] = "application/json"; map["X-Bmob-Application-Id"] = "ce30565639d0fb10cd925b5b024c3408"; map["X-Bmob-REST-API-Key"] = "4057ff07b1bec5590fb4ff0a16141938"; http.Response response = await http.get(dataUrl, headers: map); print("$&#123;response.body&#125;"); //解析数据 BookResponse baseResponse = new BookResponse(response.body); //通知界面更新状态，刷新界面 setState(() &#123; _books = baseResponse.data; &#125;);&#125; Post方式请求将get方式中的http.get() 方法改为 http.post() 方法，并添加参数body即可：12345678910111213141516171819void _postData(Book book) async &#123; String dataUrl = "https://api.bmob.cn/1/classes/book/"; //设置请求头 Map&lt;String, String&gt; map = new Map(); map["Content-Type"] = "application/json"; map["X-Bmob-Application-Id"] = "ce30565639d0fb10cd925b5b024c3408"; map["X-Bmob-REST-API-Key"] = "4057ff07b1bec5590fb4ff0a16141938"; try &#123; //使用Post方式 http.Response response = await http.post(dataUrl, headers: map, body: json.encode(book)); print("$&#123;response.body&#125;"); &#125; on Exception catch (e) &#123; print("exception $e"); SnackBar mSnackBar = new SnackBar(content: new Text("上传数据错误")); Scaffold.of(context).showSnackBar(mSnackBar); &#125;&#125; 更多用法参考官方示例]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter之扫盲篇]]></title>
    <url>%2F2018%2F08%2F06%2Fflutter-introduction%2F</url>
    <content type="text"><![CDATA[什么是FlutterFlutter是Google推出的跨平台SDK，同一份代码即可在Android和IOS系统上运行，使用Dart作为开发语言。2018年6月Flutter发布了首个预览版，到目前为止正式版本还未发布。Flutter是在GitHub上开源，SDK代码和相关支持库也在不断更新中，可以持续关注。 官方简介： Flutter 是 Google 用以帮助开发者在 iOS 和 Android 两个平台开发高质量原生 UI 的移动 SDK。Flutter 兼容现有的代码，免费且开源，在全球开发者中广泛被使用。 Flutter拥有以下特点： 快速开发：Flutter的热重载可以快速地进行测试、构建UI、添加功能并更快地修复错误。 富有表现力，漂亮的用户界面：自带的Material Design和Cupertino（iOS风格）widget、丰富的motion API、平滑而自然的滑动效果。 响应式框架：使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。 访问本地功能和SDK：Flutter可以复用现有的Java、Swift或ObjC代码，访问iOS和Android上的原生系统功能和系统SDK。 统一的应用开发体验：Flutter拥有丰富的工具和库，可以帮助开发者轻松地同时在iOS和Android系统中实现想法和创意。 原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。 Flutter和React Native有什么区别？React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，目前支持iOS和安卓两大平台，使用JavaScript语言开发。相较于Flutter，RN发展更早，使用的人数更多，第三方库也更加丰富。但是在使用RN时，需要编写一些桥接代码，不能完全实现跨平台。加上Facebook使用的开源许可证可能带来的法律风险，AirBnb、阿里巴巴和百度等大公司也相继宣布不再采用RN。 Flutter在跨平台方面做得会更加彻底，例如RN的UI组件最终都会转化为原生UI组件，而Flutter是自己实现，直接丢弃了原生UI组件，因此在各个平台上的表现一致性更高。Flutter在调用系统服务时，仍然需要根据平台配置，也不能完全做到平台无关。目前和RN相比较，Flutter并没有太大优势，不过Flutter还很年轻，Google与及广大开发者一起不断的维护和更新中。有消息称，Flutter作为Google开发的全新系统Fuchsia的开发框架，未来可期。 Flutter和RN的对比图： Flutter怎么用？Flutter官网文档很全面，从入门到精通看 这里 就够了。 Flutter初体验 安装环境 在Android Studio中安装插件Flutter和Dart，安装完成后重启Android Studio即可使用Flutter。 创建Flutter工程并运行 创建Flutter工程与创建Android工程方式一样，选择File &gt;New Flutter Project，按照指引创建，运行则点击运行图标。 Flutter热重载 修改代码后保存即可在手机上看到修改后的效果。 Flutter组件简介一切皆组件。 组件(Widget)是构建Flutter UI的基础。在Flutter中，组件是响应式的，描述了当前状态下该界面显示位置和内容，当组件的状态发生变化时会重建(rebuild)。组件分为有状态组件(StatefulWidget)和无状态组件(StatelessWidget)。有状态组件是指有可能会发生变化的组件，例如显示的内容、位置发生变化。无状态组件是指显示之后就不会发生变化。 Flutter 版Hello World： 123456789101112import 'package:flutter/material.dart';void main() &#123; runApp( new Center( child: new Text( 'Hello, world!', textDirection: TextDirection.ltr, ), ), );&#125; 这是Flutter 应用最小的代码结构，runApp()是Flutter应用的入口，需要传入一个组件。Center和Text都是一个组件，描述了界面显示的位置和内容。 Flutter 版计数器：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: new MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125;//有状态组件class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; new _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; //更新组件状态，刷新界面 setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), //界面内容 body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Text( 'You have pushed the button this many times:', ), //显示当前计数器的值 new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), //点击浮动按钮递增 floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), ); &#125;&#125; 这段代码中的MyHomePage是有状态的组件，会动态刷新页面中间的数字。点击一次浮动按钮floatingActionButton时，会触发onPressed事件执行_incrementCounter方法，在_incrementCounter方法中，计数器加1，并调用有状态组件的setState方法，刷新组件显示的内容。 运行的截图如下： Flutter与Android原生开发的区别？本节主要参考官方文档Flutter for Android Developers 1.Flutter中有View吗？ 在Android里，View是屏幕上显示的基础，Flutter与之类似的是组件widget。在Flutter中没有XML的布局文件，而是在代码中编写组件树widget tree来完成界面布局。当界面中显示的内容有变化时，通过更新有状态组件StatefulWidget的State来刷新界面。 2.Activity 和 Fragment 呢？ 一切皆组件，Activity和Fragment在Flutter里面也属于组件widget的范畴。组件的生命周期里有初始化、状态改变、销毁这三种状态。 在Flutter中弱化了生命周期的概念，文档中写道： If you need to observe the lifecycle to acquire or release any native resources, you should likely be doing it from the native side, at any rate. 3.没有Activity，怎么跳转页面？ Flutter 没有 Intent,可以通过Navigator和Route来实现页面间的跳转。12345678910111213void main() &#123; runApp(new MaterialApp( home: new MyAppHome(), // becomes the route named '/' routes: &lt;String, WidgetBuilder&gt; &#123; '/a': (BuildContext context) =&gt; new MyPage(title: 'page A'), '/b': (BuildContext context) =&gt; new MyPage(title: 'page B'), '/c': (BuildContext context) =&gt; new MyPage(title: 'page C'), &#125;, ));&#125;//跳转页面Navigator.of(context).pushNamed('/b'); 4.怎么使用相机、GPS之类的功能？ 使用Flutter插件(plugins)，也就是通过第三方库来使用这些功能。Flutter的第三方库都可以在这里搜索。 5.怎么切换主线程和后台线程？ Flutter默认在主线程上运行，访问网络等需要异步线程的，则使用async和await,例如下面这个请求网络并刷新界面的例子：1234567loadData() async &#123; String dataURL = "https://jsonplaceholder.typicode.com/posts"; http.Response response = await http.get(dataURL); setState(() &#123; widgets = json.decode(response.body); &#125;);&#125; 参考文档Flutter Vs. React Native: Let’s See Who the Winner is Flutter框架研究和与RN对比 Flutter - 不一样的跨平台解决方案 Flutter Technical Overview flutter中的生命周期]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
